// services/marketingAutomation.js
import mongoose from "mongoose";
import { StudentEvaluation, MarketingAction, MarketingCampaign } from "@/lib/models";
import Student from "../models/Student";
import Group from "../models/Group";
import Course from "../models/Course";

/**
 * ‚úÖ EVENT: Instructor Evaluation Submitted
 */
export async function triggerEvaluationFollowup(evaluationId, triggeredBy) {
  try {
    console.log(`\nüéØ EVENT: Instructor Evaluation Submitted ==========`);
    console.log(`üìù Evaluation: ${evaluationId}`);
    console.log(`üë§ Triggered by: ${triggeredBy}`);

    // ÿ¨ŸÑÿ® ÿßŸÑÿ™ŸÇŸäŸäŸÖ ŸÖÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ±ÿ™ÿ®ÿ∑ÿ©
    const evaluation = await StudentEvaluation.findById(evaluationId)
      .populate(
        "studentId",
        "personalInfo.fullName personalInfo.whatsappNumber personalInfo.email communicationPreferences"
      )
      .populate("groupId", "name code courseId")
      .populate({
        path: "groupId",
        populate: {
          path: "courseId",
          select: "title level",
        },
      });

    if (!evaluation || !evaluation.studentId || !evaluation.groupId) {
      throw new Error("Evaluation data incomplete");
    }

    const student = evaluation.studentId;
    const group = evaluation.groupId;
    const course = group.courseId;

    console.log(`üìä Evaluation details:`);
    console.log(`   Student: ${student.personalInfo?.fullName}`);
    console.log(`   Group: ${group.name} (${group.code})`);
    console.log(`   Course: ${course?.title}`);
    console.log(`   Decision: ${evaluation.finalDecision}`);
    console.log(`   Overall Score: ${evaluation.calculatedStats?.overallScore}`);

    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿ≠ŸÖŸÑÿ© ÿ™ÿ≥ŸàŸäŸÇŸäÿ© ŸÜÿ¥ÿ∑ÿ©
    let campaign = await MarketingCampaign.findOne({
      campaignType: "evaluation_followup",
      status: "active",
      "targetCriteria.evaluationDecisions": evaluation.finalDecision,
    });

    // ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™Ÿàÿ¨ÿØ ÿ≠ŸÖŸÑÿ©ÿå ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ŸÖŸÑÿ© ÿ™ŸÑŸÇÿßÿ¶Ÿäÿ©
    if (!campaign) {
      campaign = await createAutoCampaign(evaluation.finalDecision, triggeredBy);
    }

    // ÿ•ŸÜÿ¥ÿßÿ° ÿ•ÿ¨ÿ±ÿßÿ° ÿ™ÿ≥ŸàŸäŸÇŸä
    const marketingAction = await MarketingAction.create({
      actionType: getActionType(evaluation.finalDecision),
      targetStudent: evaluation.studentId._id,
      targetGroup: evaluation.groupId._id,
      evaluationId: evaluation._id,
      actionData: await generateActionData(evaluation, student, group, course),
      communicationChannels: {
        whatsapp: true,
        email: student.personalInfo?.email ? true : false,
        sms: false,
      },
      status: "pending",
      metadata: {
        createdBy: triggeredBy,
        createdAt: new Date(),
      },
    });

    console.log(`‚úÖ Marketing action created: ${marketingAction._id}`);

    // ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑÿ™ÿ≥ŸàŸäŸÇŸä
    await executeMarketingAction(marketingAction._id);

    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ŸÇŸäŸäŸÖ
    await StudentEvaluation.findByIdAndUpdate(evaluationId, {
      $push: { "marketing.followupActions": marketingAction._id },
      $set: {
        "marketing.followupCampaign": campaign._id,
        "marketing.followupStatus": "completed",
        "metadata.updatedAt": new Date(),
      },
    });

    return {
      success: true,
      actionId: marketingAction._id,
      campaignId: campaign._id,
      studentCategory: evaluation.marketing?.studentCategory,
      nextSteps: evaluation.marketing?.nextSteps,
    };
  } catch (error) {
    console.error("‚ùå Error in triggerEvaluationFollowup:", error);
    throw error;
  }
}

/**
 * ‚úÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ŸÖŸÑÿ© ÿ™ÿ≥ŸàŸäŸÇŸäÿ© ÿ™ŸÑŸÇÿßÿ¶Ÿäÿ©
 */
async function createAutoCampaign(decision, createdBy) {
  console.log(`üìù Creating auto campaign for decision: ${decision}`);

  const campaignData = {
    name: `Auto Campaign - ${decision.toUpperCase()}`,
    description: `Automatically generated campaign for ${decision} evaluation decisions`,
    campaignType: "evaluation_followup",
    targetCriteria: {
      evaluationDecisions: [decision],
    },
    automationRules: {
      trigger: "evaluation_completed",
      delayHours: 24,
      maxRetries: 3,
      followupSchedule: [
        { daysAfter: 3, actionType: "followup" },
        { daysAfter: 7, actionType: "reminder" },
      ],
    },
    messages: generateMessageTemplates(decision),
    offers: generateOffers(decision),
    status: "active",
    metadata: {
      createdBy,
      createdAt: new Date(),
      autoGenerated: true,
    },
  };

  const campaign = await MarketingCampaign.create(campaignData);
  console.log(`‚úÖ Auto campaign created: ${campaign._id}`);
  return campaign;
}

/**
 * ‚úÖ ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑŸÇÿ±ÿßÿ±
 */
function getActionType(decision) {
  const actionMap = {
    pass: "upsell",
    review: "support",
    repeat: "re_enroll",
  };
  return actionMap[decision] || "support";
}

/**
 * ‚úÖ ÿ™ŸàŸÑŸäÿØ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑÿ™ÿ≥ŸàŸäŸÇŸä
 */
async function generateActionData(evaluation, student, group, course) {
  console.log("üß† Generating AI-powered action data...");

  const weakPoints = evaluation.weakPoints || [];
  const strengths = evaluation.strengths || [];

  // ÿ™ŸàŸÑŸäÿØ ÿ±ÿ≥ÿßŸÑÿ© ÿ∞ŸÉŸäÿ©
  const aiMessage = generateAIMessage(evaluation, student, group, course);

  // ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿπÿ±ÿ∂ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®
  const offer = generateOffer(
    evaluation.finalDecision,
    evaluation.calculatedStats?.overallScore
  );

  return {
    customMessage: aiMessage,
    discountPercentage: offer.discount,
    supportPackage: offer.support,
    nextLevel: offer.nextLevel,
    deadline: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    weakPoints,
    aiGenerated: true,
    generatedAt: new Date(),
  };
}

/**
 * ‚úÖ ÿ™ŸàŸÑŸäÿØ ÿ±ÿ≥ÿßŸÑÿ© ÿ∞ŸÉŸäÿ©
 */
function generateAIMessage(evaluation, student, group, course) {
  const studentName = student.personalInfo?.fullName || "ÿ∑ÿßŸÑÿ®ŸÜÿß ÿßŸÑÿπÿ≤Ÿäÿ≤";
  const courseName = course?.title || "ÿßŸÑŸÉŸàÿ±ÿ≥";

  // ŸÜŸÇÿßÿ∑ ÿßŸÑŸÇŸàÿ© ŸàÿßŸÑÿ∂ÿπŸÅ
  const weakPointsAr = evaluation.weakPoints?.map((wp) => {
    const map = {
      understanding: "ÿßŸÑŸÅŸáŸÖ ÿßŸÑŸÜÿ∏ÿ±Ÿä",
      practice: "ÿßŸÑŸÖŸÖÿßÿ±ÿ≥ÿ© ÿßŸÑÿπŸÖŸÑŸäÿ©",
      attendance: "ÿßŸÑÿßŸÜÿ™ÿ∏ÿßŸÖ ŸÅŸä ÿßŸÑÿ≠ÿ∂Ÿàÿ±",
      participation: "ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉÿ© ŸÅŸä ÿßŸÑŸÅÿµŸÑ",
      homework: "ÿ•ŸÜÿ¨ÿßÿ≤ ÿßŸÑŸàÿßÿ¨ÿ®ÿßÿ™",
      projects: "ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ",
    };
    return map[wp] || wp;
  }) || [];

  const strengthsAr = evaluation.strengths?.map((st) => {
    const map = {
      fast_learner: "ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ™ÿπŸÑŸÖ",
      hard_worker: "ÿßŸÑÿßÿ¨ÿ™ŸáÿßÿØ",
      team_player: "ÿßŸÑÿπŸÖŸÑ ÿßŸÑÿ¨ŸÖÿßÿπŸä",
      creative: "ÿßŸÑÿ•ÿ®ÿØÿßÿπ",
      problem_solver: "ÿ≠ŸÑ ÿßŸÑŸÖÿ¥ŸÉŸÑÿßÿ™",
      consistent: "ÿßŸÑÿßŸÜÿ™ÿ∏ÿßŸÖ",
    };
    return map[st] || st;
  }) || [];

  switch (evaluation.finalDecision) {
    case "pass":
      if (evaluation.calculatedStats?.overallScore >= 4.5) {
        return `üéâ ŸÖÿ®ÿ±ŸàŸÉ ${studentName}!
ÿ£ÿØÿßÿ§ŸÉ ŸÅŸä ${courseName} ŸÉÿßŸÜ ÿßÿ≥ÿ™ÿ´ŸÜÿßÿ¶ŸäÿßŸã! üèÜ
${strengthsAr.length > 0 ? `ŸÜŸÇÿßÿ∑ ŸÇŸàÿ™ŸÉ: ${strengthsAr.join(" Ÿà ")} üëè` : ""}
ŸÖÿ≥ÿ™ÿπÿØ ŸÑŸÑÿ™ÿ≠ÿØŸä ÿßŸÑŸÇÿßÿØŸÖÿü ÿπŸÜÿØŸÜÿß ÿßŸÑŸÉŸàÿ±ÿ≥ ÿßŸÑŸÖÿ™ŸÇÿØŸÖ ÿ®ÿÆÿµŸÖ 20% ÿÆÿßÿµ ŸÑŸÉ.
ÿ£ŸÜÿ™ ÿ£Ÿäÿ∂ÿßŸã ŸÖÿ§ŸáŸÑ ŸÑÿ®ÿ±ŸÜÿßŸÖÿ¨ ÿßŸÑÿ•ÿ≠ÿßŸÑÿßÿ™ - ŸÉŸÑ ÿµÿØŸäŸÇ ÿ™ÿ¨Ÿäÿ®Ÿá ŸÑŸäŸÉ 15% ÿÆÿµŸÖ ÿ•ÿ∂ÿßŸÅŸä!

‚è∞ ÿßŸÑÿπÿ±ÿ∂ ÿ≥ÿßÿ±Ÿä ŸÑŸÖÿØÿ© ÿ£ÿ≥ÿ®Ÿàÿπ ŸÅŸÇÿ∑!
üöÄ ÿßŸÜÿ∑ŸÑŸÇ ŸÑŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ™ÿßŸÑŸä!`;
      } else {
        return `üëç ÿ£ÿ≠ÿ≥ŸÜÿ™ ${studentName}!
ÿ£ŸÉŸÖŸÑÿ™ ${courseName} ÿ®ŸÜÿ¨ÿßÿ≠ üéì
${weakPointsAr.length > 0 ? `ŸÜÿµŸäÿ≠ÿ©: ÿ±ŸÉÿ≤ ÿ£ŸÉÿ´ÿ± ÿπŸÑŸâ ${weakPointsAr[0]} ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÇÿßÿØŸÖ üí°` : ""}
ŸÖÿ≥ÿ™ÿπÿØ ŸÑŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ™ÿßŸÑŸäÿü ÿπŸÜÿØŸÉ ÿÆÿµŸÖ 15% ÿπŸÑŸâ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÖÿ®ŸÉÿ±.

üìû ÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÜÿß ÿÆŸÑÿßŸÑ ÿ£ÿ≥ÿ®Ÿàÿπ ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿÆÿµŸÖ!`;
      }

    case "review":
      if (weakPointsAr.length > 2) {
        return `üîî ${studentName}ÿå ÿπŸÜÿØŸÜÿß ÿÆÿ∑ÿ© ÿÆÿßÿµÿ© ŸÑŸÉ!
ŸÜÿπÿ±ŸÅ ÿ•ŸÜ ${courseName} ŸÉÿßŸÜ ÿ™ÿ≠ÿØŸäÿßŸã üí™
${weakPointsAr.length > 0 ? `ÿßŸÑŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑŸÑŸä ŸÖÿ≠ÿ™ÿßÿ¨ÿ© ÿØÿπŸÖ: ${weakPointsAr.join("ÿå ")}` : ""}

ÿ®ŸÜŸÇÿ™ÿ±ÿ≠:
‚úÖ ÿ¨ŸÑÿ≥ÿßÿ™ ÿØÿπŸÖ ŸÖŸÉÿ´ŸÅÿ© (3 ÿ¨ŸÑÿ≥ÿßÿ™ ŸÖÿ¨ÿßŸÜŸäÿ©)
‚úÖ ŸÖÿ±ÿßÿ¨ÿπÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ ŸÖÿπ ŸÖÿØÿ±ÿ® ŸÖÿ™ÿÆÿµÿµ
‚úÖ ÿÆÿµŸÖ 30% ŸÑŸÑÿßÿ≥ÿ™ŸÖÿ±ÿßÿ± ŸÖÿπŸÜÿß ŸÅŸä ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ≠ÿßŸÑŸä

üéØ ŸáÿØŸÅŸÜÿß: ŸÜŸàÿµŸÑ ŸÖÿπÿßŸÉ ŸÑŸÄ 100% ÿßÿ≥ÿ™ŸÅÿßÿØÿ©!
üìû ÿ±ÿØ ÿπŸÑŸäŸÜÿß ÿπÿ¥ÿßŸÜ ŸÜÿ®ÿØÿ£ ÿßŸÑÿÆÿ∑ÿ©!`;
      } else {
        return `üëã ${studentName}ÿå ÿ£ÿØÿßÿ§ŸÉ ÿ¨ŸäÿØ ŸÅŸä ${courseName}!
ŸÑŸÉŸÜ ŸÖÿ≠ÿ™ÿßÿ¨ ÿ™ÿØÿπŸäŸÖ ÿ®ÿ≥Ÿäÿ∑ ŸÅŸä: ${weakPointsAr.join(" Ÿà ")}

ÿπŸÜÿØŸÜÿß ÿ¨ŸÑÿ≥ÿßÿ™ ÿØÿπŸÖ ŸÖÿ¨ÿßŸÜŸäÿ© ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ÿßŸÑÿ¨ÿßŸä:
üìÖ ÿßŸÑÿ£ÿ≠ÿØÿå ÿßŸÑÿ•ÿ´ŸÜŸäŸÜÿå ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ°
‚è∞ ŸÖŸÜ 6-8 ŸÖÿ≥ÿßÿ°Ÿã
üéØ ÿ™ÿ±ŸÉŸäÿ≤ ÿπŸÑŸâ ${weakPointsAr[0] || "ÿßŸÑŸÖŸáÿßÿ±ÿßÿ™ ÿßŸÑÿπŸÖŸÑŸäÿ©"}

üÜì ŸÖÿ¨ÿßŸÜÿßŸã ÿ™ŸÖÿßŸÖÿßŸã!`;
      }

    case "repeat":
      return `üîÑ ${studentName}ÿå ÿπŸÑÿ¥ÿßŸÜ ÿ™ÿ≥ÿ™ŸÅŸäÿØ 100%
ÿ®ŸÜŸÇÿ™ÿ±ÿ≠ ÿ•ÿπÿßÿØÿ© ${courseName} ŸÖÿπ:
‚úÖ ÿØÿπŸÖ ÿ•ÿ∂ÿßŸÅŸä ÿ¥ÿÆÿµŸä (ÿ¨ŸÑÿ≥ÿ© ÿ£ÿ≥ÿ®ŸàÿπŸäÿßŸã)
‚úÖ ÿÆÿµŸÖ 40% ÿπŸÑŸâ ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÉŸàÿ±ÿ≥
‚úÖ ŸÖÿ±ÿßÿ¨ÿπÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ ŸàÿßŸÑÿØÿ±Ÿàÿ≥
‚úÖ ŸÖÿ™ÿßÿ®ÿπÿ© ÿ£ÿ≥ÿ®ŸàÿπŸäÿ© ŸÖÿπ ÿßŸÑŸÖÿØÿ±ÿ®

${weakPointsAr.length > 0 ? `ŸáŸÜÿ±ŸÉÿ≤ ŸÖÿπÿßŸÉ ÿπŸÑŸâ: ${weakPointsAr.join(" Ÿà ")} üéØ` : ""}

üí™ ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ¨ÿßŸä ÿ®ÿ™ŸÉŸàŸÜ ÿ£ŸÇŸàŸâ ŸàŸÖÿ≥ÿ™ÿπÿØ 100%!
üí∞ ÿßŸÑÿ≥ÿπÿ± ÿ®ÿπÿØ ÿßŸÑÿÆÿµŸÖ: [ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ£ÿµŸÑŸä √ó 60%]
üìû ÿ±ÿØ ÿπŸÑÿ¥ÿßŸÜ ŸÜÿ≠ÿ¨ÿ≤ ŸÖŸÉÿßŸÜŸÉ!`;

    default:
      return `ŸÖÿ±ÿ≠ÿ®ÿßŸã ${studentName}ÿå
ÿ™ŸáÿßŸÜŸäŸÜÿß ÿπŸÑŸâ ÿ•ÿ™ŸÖÿßŸÖ ${courseName}!
ŸÜÿ™ŸÖŸÜŸâ ŸÑŸÉ ÿßŸÑÿ™ŸàŸÅŸäŸÇ ŸÅŸä ŸÖÿ≥Ÿäÿ±ÿ™ŸÉ ÿßŸÑÿ™ÿπŸÑŸäŸÖŸäÿ©.`;
  }
}

/**
 * ‚úÖ ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿπÿ±Ÿàÿ∂ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑŸÇÿ±ÿßÿ± ŸàÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©
 */
function generateOffer(decision, overallScore) {
  const offers = {
    pass: {
      discount: overallScore >= 4.5 ? 20 : 15,
      support: "advanced_level_access",
      nextLevel: "ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑŸÖÿ™ŸÇÿØŸÖ",
    },
    review: {
      discount: 30,
      support: "intensive_support_package",
      nextLevel: "ŸÜŸÅÿ≥ ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ŸÖÿπ ÿØÿπŸÖ",
    },
    repeat: {
      discount: 40,
      support: "personal_coaching",
      nextLevel: "ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÉŸàÿ±ÿ≥",
    },
  };

  return offers[decision] || {
    discount: 10,
    support: "basic_support",
    nextLevel: "ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ™ÿßŸÑŸä",
  };
}

/**
 * ‚úÖ ÿ™ŸàŸÑŸäÿØ ŸÇŸàÿßŸÑÿ® ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ
 */
function generateMessageTemplates(decision) {
  const templates = {
    pass: {
      template: `ŸÖÿ®ÿ±ŸàŸÉ {studentName}! üéâ
ÿ£ÿØÿßÿ§ŸÉ ŸÅŸä {courseName} ŸÉÿßŸÜ {performance}.
ŸÖÿ≥ÿ™ÿπÿØ ŸÑŸÑŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ™ÿßŸÑŸä? ÿπŸÜÿØŸÉ ÿÆÿµŸÖ {discount}%!
{strengthsMessage}
{offerMessage}`,
      variables: [
        "studentName",
        "courseName",
        "performance",
        "discount",
        "strengthsMessage",
        "offerMessage",
      ],
      aiEnhanced: true,
    },
    review: {
      template: `{studentName}ÿå ÿ£ÿØÿßÿ§ŸÉ ŸÅŸä {courseName} ÿ¨ŸäÿØ üëã
ŸÑŸÉŸÜ ŸÖÿ≠ÿ™ÿßÿ¨ ÿ™ÿØÿπŸäŸÖ ŸÅŸä: {weakPoints}
ÿπŸÜÿØŸÜÿß {supportPackage} ÿ®ÿÆÿµŸÖ {discount}%!
{nextSteps}`,
      variables: [
        "studentName",
        "courseName",
        "weakPoints",
        "supportPackage",
        "discount",
        "nextSteps",
      ],
      aiEnhanced: true,
    },
    repeat: {
      template: `{studentName}ÿå ÿπŸÑÿ¥ÿßŸÜ ÿ™ÿ≥ÿ™ŸÅŸäÿØ 100% üéØ
ÿ®ŸÜŸÇÿ™ÿ±ÿ≠ ÿ•ÿπÿßÿØÿ© {courseName} ŸÖÿπ:
‚úÖ {supportPackage}
‚úÖ ÿÆÿµŸÖ {discount}%
‚úÖ {additionalBenefits}
ŸÖÿ≥ÿ™ÿπÿØ ŸÑŸÑÿßŸÜÿ∑ŸÑÿßŸÇ ŸÖŸÜ ÿ¨ÿØŸäÿØ? üí™`,
      variables: [
        "studentName",
        "courseName",
        "supportPackage",
        "discount",
        "additionalBenefits",
      ],
      aiEnhanced: true,
    },
  };

  return templates[decision] || templates.review;
}

/**
 * ‚úÖ ÿ™ŸàŸÑŸäÿØ ÿßŸÑÿπÿ±Ÿàÿ∂ ÿßŸÑÿπÿßŸÖÿ©
 */
function generateOffers(decision) {
  const offers = {
    pass: {
      discountPercentage: 15,
      supportSessions: 0,
      deadlineDays: 7,
      referralBonus: "ÿÆÿµŸÖ 15% ÿ•ÿ∂ÿßŸÅŸä ŸÑŸÉŸÑ ÿµÿØŸäŸÇ",
    },
    review: {
      discountPercentage: 30,
      supportSessions: 3,
      deadlineDays: 14,
      referralBonus: "ÿ¨ŸÑÿ≥ÿ© ÿØÿπŸÖ ŸÖÿ¨ÿßŸÜŸäÿ©",
    },
    repeat: {
      discountPercentage: 40,
      supportSessions: 8,
      deadlineDays: 30,
      referralBonus: "ÿÆÿµŸÖ 20% ÿπŸÑŸâ ŸÉŸàÿ±ÿ≥ ÿ¢ÿÆÿ±",
    },
  };

  return offers[decision] || offers.review;
}

/**
 * ‚úÖ ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ÿßŸÑÿ™ÿ≥ŸàŸäŸÇŸä
 */
async function executeMarketingAction(actionId) {
  try {
    console.log(`üöÄ Executing marketing action: ${actionId}`);

    const action = await MarketingAction.findById(actionId)
      .populate(
        "targetStudent",
        "personalInfo.fullName personalInfo.whatsappNumber personalInfo.email"
      )
      .populate("targetGroup", "name code");

    if (!action) {
      throw new Error("Marketing action not found");
    }

    const student = action.targetStudent;
    const whatsappNumber = student.personalInfo?.whatsappNumber;

    if (!whatsappNumber) {
      console.log(`‚ö†Ô∏è No WhatsApp number for student ${student.personalInfo?.fullName}`);
      action.status = "failed";
      action.results.notes = "No WhatsApp number";
      await action.save();
      return;
    }

    // ŸÖÿ≠ÿßŸÉÿßÿ© ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© (Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿ®ÿØÿßŸÑŸáÿß ÿ®ŸÄ wapilotService ÿßŸÑÿ≠ŸÇŸäŸÇŸä)
    console.log(`üì§ Simulating WhatsApp message to ${whatsappNumber}:`);
    console.log(`Message: ${action.actionData.customMessage.substring(0, 100)}...`);

    // ŸÖÿ≠ÿßŸÉÿßÿ© ŸÜÿ¨ÿßÿ≠ ÿßŸÑÿ•ÿ±ÿ≥ÿßŸÑ
    action.status = "completed";
    action.results.messageSent = true;
    action.results.sentAt = new Date();
    action.metadata.executedAt = new Date();
    action.metadata.executionLogs.push(
      `Message simulated successfully at ${new Date().toISOString()}`
    );

    console.log(`‚úÖ Marketing message simulated to ${student.personalInfo?.fullName}`);

    await action.save();

    // ÿ™ÿ≠ÿØŸäÿ´ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ≠ŸÖŸÑÿ© ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ŸÖÿ±ÿ™ÿ®ÿ∑ÿ©
    if (action.evaluationId) {
      await updateCampaignStats(action.evaluationId.marketing?.followupCampaign);
    }
  } catch (error) {
    console.error(`‚ùå Error executing marketing action ${actionId}:`, error);

    await MarketingAction.findByIdAndUpdate(actionId, {
      $set: {
        status: "failed",
        "results.notes": error.message,
        "metadata.executionLogs": [`Error: ${error.message}`],
      },
    });
  }
}

/**
 * ‚úÖ ÿ™ÿ≠ÿØŸäÿ´ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ≠ŸÖŸÑÿ©
 */
async function updateCampaignStats(campaignId) {
  try {
    if (!campaignId) return;

    const stats = await MarketingAction.aggregate([
      {
        $match: {
          $or: [
            { "metadata.campaignId": campaignId },
            { "evaluationId.marketing.followupCampaign": campaignId }
          ]
        }
      },
      {
        $group: {
          _id: "$status",
          count: { $sum: 1 },
        },
      },
    ]);

    const total = stats.reduce((sum, stat) => sum + stat.count, 0);
    const completed = stats.find((s) => s._id === "completed")?.count || 0;
    const conversionRate = total > 0 ? (completed / total) * 100 : 0;

    await MarketingCampaign.findByIdAndUpdate(campaignId, {
      $set: {
        "stats.totalTargets": total,
        "stats.messagesSent": completed,
        "stats.conversions": completed,
        "stats.conversionRate": parseFloat(conversionRate.toFixed(2)),
      },
    });
  } catch (error) {
    console.error("‚ùå Error updating campaign stats:", error);
  }
}

/**
 * ‚úÖ EVENT: Group Completed - Marketing Followup
 */
export async function onGroupCompletedMarketing(groupId, triggeredBy) {
  try {
    console.log(`\nüéØ EVENT: Group Completed - Marketing Followup ==========`);
    console.log(`üë• Group: ${groupId}`);

    const evaluations = await StudentEvaluation.find({
      groupId,
      isDeleted: false,
      "marketing.followupStatus": { $ne: "completed" },
    })
      .populate("studentId", "personalInfo.fullName personalInfo.whatsappNumber")
      .lean();

    console.log(`üìä Found ${evaluations.length} evaluations for marketing followup`);

    if (evaluations.length === 0) {
      console.log("‚ö†Ô∏è No evaluations found for marketing followup");
      return {
        success: false,
        message: "No evaluations found for marketing followup",
      };
    }

    const campaign = await MarketingCampaign.create({
      name: `Group Completion - ${groupId}`,
      description: `Marketing followup for completed group ${groupId}`,
      campaignType: "group_completed",
      targetCriteria: { groups: [groupId] },
      automationRules: {
        trigger: "group_completed",
        delayHours: 48,
        maxRetries: 2,
      },
      status: "active",
      metadata: {
        createdBy: triggeredBy,
        createdAt: new Date(),
      },
    });

    let successCount = 0;
    let failCount = 0;
    const results = [];

    for (const evaluation of evaluations) {
      try {
        const result = await triggerEvaluationFollowup(evaluation._id, triggeredBy);
        if (result.success) {
          successCount++;
          results.push({
            studentId: evaluation.studentId._id,
            studentName: evaluation.studentId.personalInfo?.fullName,
            success: true,
            actionId: result.actionId,
          });
        } else {
          failCount++;
          results.push({
            studentId: evaluation.studentId._id,
            studentName: evaluation.studentId.personalInfo?.fullName,
            success: false,
            error: result.error,
          });
        }
      } catch (error) {
        failCount++;
        results.push({
          studentId: evaluation.studentId._id,
          studentName: evaluation.studentId.personalInfo?.fullName,
          success: false,
          error: error.message,
        });
      }
    }

    console.log(`\nüìä Group completion marketing results:`);
    console.log(`   Success: ${successCount}`);
    console.log(`   Failed: ${failCount}`);
    console.log(`   Campaign: ${campaign._id}`);

    await MarketingCampaign.findByIdAndUpdate(campaign._id, {
      $set: {
        "stats.totalTargets": evaluations.length,
        "stats.messagesSent": successCount,
        "stats.conversions": 0,
        "stats.conversionRate": parseFloat(((successCount / evaluations.length) * 100).toFixed(2)),
        "stats.startDate": new Date(),
      },
    });

    return {
      success: successCount > 0,
      campaignId: campaign._id,
      total: evaluations.length,
      successCount,
      failCount,
      results,
    };
  } catch (error) {
    console.error("‚ùå Error in onGroupCompletedMarketing:", error);
    throw error;
  }
}

/**
 * ‚úÖ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿ™ÿ≥ŸàŸäŸÇ
 */
export async function getMarketingStats(timeframe = "month") {
  try {
    const dateFilter = getDateFilter(timeframe);

    const stats = await MarketingAction.aggregate([
      {
        $match: {
          createdAt: dateFilter,
        },
      },
      {
        $group: {
          _id: "$actionType",
          total: { $sum: 1 },
          completed: { $sum: { $cond: [{ $eq: ["$status", "completed"] }, 1, 0] } },
          failed: { $sum: { $cond: [{ $eq: ["$status", "failed"] }, 1, 0] } },
        },
      },
    ]);

    const totalStats = await MarketingAction.aggregate([
      {
        $match: {
          createdAt: dateFilter,
        },
      },
      {
        $group: {
          _id: null,
          totalActions: { $sum: 1 },
          totalCompleted: { $sum: { $cond: [{ $eq: ["$status", "completed"] }, 1, 0] } },
          uniqueStudents: { $addToSet: "$targetStudent" },
        },
      },
    ]);

    const campaignStats = await MarketingCampaign.aggregate([
      {
        $match: {
          createdAt: dateFilter,
          status: "active",
        },
      },
      {
        $group: {
          _id: null,
          activeCampaigns: { $sum: 1 },
          totalTargets: { $sum: "$stats.totalTargets" },
          totalMessages: { $sum: "$stats.messagesSent" },
        },
      },
    ]);

    const evaluationStats = await StudentEvaluation.aggregate([
      {
        $match: {
          "metadata.evaluatedAt": dateFilter,
        },
      },
      {
        $group: {
          _id: "$finalDecision",
          count: { $sum: 1 },
        },
      },
    ]);

    const decisions = {
      pass: evaluationStats.find((e) => e._id === "pass")?.count || 0,
      review: evaluationStats.find((e) => e._id === "review")?.count || 0,
      repeat: evaluationStats.find((e) => e._id === "repeat")?.count || 0,
    };

    return {
      timeframe,
      total: {
        actions: totalStats[0]?.totalActions || 0,
        completed: totalStats[0]?.totalCompleted || 0,
        students: totalStats[0]?.uniqueStudents?.length || 0,
        successRate: totalStats[0]?.totalActions
          ? parseFloat(((totalStats[0]?.totalCompleted / totalStats[0]?.totalActions) * 100).toFixed(2))
          : 0,
      },
      byActionType: stats.reduce((acc, stat) => {
        acc[stat._id] = {
          total: stat.total,
          completed: stat.completed,
          failed: stat.failed,
          successRate: parseFloat(((stat.completed / stat.total) * 100).toFixed(2)),
        };
        return acc;
      }, {}),
      campaigns: {
        active: campaignStats[0]?.activeCampaigns || 0,
        totalTargets: campaignStats[0]?.totalTargets || 0,
        messagesSent: campaignStats[0]?.totalMessages || 0,
      },
      evaluations: decisions,
    };
  } catch (error) {
    console.error("‚ùå Error getting marketing stats:", error);
    throw error;
  }
}

/**
 * ‚úÖ ŸÅŸÑÿ™ÿ±ÿ© ÿßŸÑÿ™ÿßÿ±ŸäÿÆ
 */
function getDateFilter(timeframe) {
  const now = new Date();
  let startDate;

  switch (timeframe) {
    case "day":
      startDate = new Date(now.setDate(now.getDate() - 1));
      break;
    case "week":
      startDate = new Date(now.setDate(now.getDate() - 7));
      break;
    case "month":
      startDate = new Date(now.setMonth(now.getMonth() - 1));
      break;
    case "quarter":
      startDate = new Date(now.setMonth(now.getMonth() - 3));
      break;
    case "year":
      startDate = new Date(now.setFullYear(now.getFullYear() - 1));
      break;
    default:
      startDate = new Date(now.setMonth(now.getMonth() - 1));
  }

  return { $gte: startDate };
}

export default {
  triggerEvaluationFollowup,
  onGroupCompletedMarketing,
  getMarketingStats,
  executeMarketingAction,
};